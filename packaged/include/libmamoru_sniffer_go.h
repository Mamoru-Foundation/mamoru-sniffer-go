/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_MAMORU_SNIFFER_C__
#define __RUST_MAMORU_SNIFFER_C__

#ifdef __cplusplus
extern "C" {
#endif

/** \brief
 *  Initializes the logger using exported `mamoru_sniffer_logger` function.
 *  Default log level is `ERROR`, use `export RUST_LOG=info` to enable info logs.
 *  The logger will be initialized only once.
 */
void init_logger (void);

typedef struct FfiCosmosBlockchainDataBuilder FfiCosmosBlockchainDataBuilder_t;

FfiCosmosBlockchainDataBuilder_t * new_cosmos_blockchain_data_builder (void);

void cosmos_blockchain_data_builder_set_tx (
    FfiCosmosBlockchainDataBuilder_t * builder,
    char const * tx_id,
    char const * tx_hash);

void cosmos_blockchain_data_builder_set_block (
    FfiCosmosBlockchainDataBuilder_t * builder,
    char const * block_id,
    char const * block_hash);

void cosmos_blockchain_data_builder_set_mempool_source (
    FfiCosmosBlockchainDataBuilder_t * builder);


#include <stddef.h>
#include <stdint.h>

void cosmos_blockchain_data_builder_set_statistics (
    FfiCosmosBlockchainDataBuilder_t * builder,
    uint64_t blocks,
    uint64_t transactions,
    uint64_t events,
    uint64_t call_traces);

typedef struct FfiCosmosBlockchainDataCtx FfiCosmosBlockchainDataCtx_t;

/** \brief
 *  Frees `builder` argument.
 */
FfiCosmosBlockchainDataCtx_t * cosmos_blockchain_data_builder_finish (
    FfiCosmosBlockchainDataBuilder_t * builder);

typedef struct FfiSniffer FfiSniffer_t;

/** \brief
 *  Frees `data` argument.
 */
void cosmos_sniffer_observe_data (
    FfiSniffer_t const * sniffer,
    FfiCosmosBlockchainDataCtx_t * data);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8 {

    uint8_t const * ptr;

    size_t len;

} slice_ref_uint8_t;

void cosmos_transaction_append (
    FfiCosmosBlockchainDataBuilder_t * builder,
    slice_ref_uint8_t tx_data,
    char const * tx_hash,
    uint32_t tx_index,
    uint32_t code,
    slice_ref_uint8_t data,
    char const * log,
    char const * info,
    int64_t gas_wanted,
    int64_t gas_used,
    char const * codespace);

void cosmos_block_set (
    FfiCosmosBlockchainDataBuilder_t * builder,
    uint64_t seq,
    int64_t height,
    char const * hash,
    uint64_t version_block,
    uint64_t version_app,
    char const * chain_id,
    int64_t time,
    char const * last_block_id_hash,
    uint32_t last_block_id_part_set_header_total,
    char const * last_block_id_part_set_header_hash,
    char const * last_commit_hash,
    char const * data_hash,
    char const * validators_hash,
    char const * next_validators_hash,
    char const * consensus_hash,
    char const * app_hash,
    char const * last_results_hash,
    char const * evidence_hash,
    char const * proposer_address,
    int32_t last_commit_info_round,
    int64_t consensus_param_updates_block_max_bytes,
    int64_t consensus_param_updates_block_max_gas,
    int64_t consensus_param_updates_evidence_max_age_num_blocks,
    int64_t consensus_param_updates_evidence_max_age_duration,
    int64_t consensus_param_updates_evidence_max_bytes,
    char const * consensus_param_updates_validator_pub_key_types,
    uint64_t consensus_param_updates_version_app);

void cosmos_event_append (
    FfiCosmosBlockchainDataBuilder_t * builder,
    uint64_t seq,
    char const * event_type);


#include <stdbool.h>

void cosmos_event_attribute_append (
    FfiCosmosBlockchainDataBuilder_t * builder,
    uint64_t seq,
    uint64_t event_seq,
    char const * key,
    char const * value,
    bool index);

void cosmos_validator_update_append (
    FfiCosmosBlockchainDataBuilder_t * builder,
    uint64_t block_seq,
    slice_ref_uint8_t pub_key,
    int64_t power);

void cosmos_misbehavior_append (
    FfiCosmosBlockchainDataBuilder_t * builder,
    uint64_t block_seq,
    char const * typ,
    int64_t validator_power,
    char const * validator_address,
    int64_t height,
    int64_t time,
    int64_t total_voting_power);

void cosmos_vote_infos_append (
    FfiCosmosBlockchainDataBuilder_t * builder,
    uint64_t block_seq,
    char const * validator_adders,
    int64_t validator_power,
    bool signed_last_block);

void cosmos_evm_call_trace_append (
    FfiCosmosBlockchainDataBuilder_t * builder,
    char const * tx_hash,
    uint32_t depth,
    uint32_t tx_index,
    int64_t block_index,
    char const * typ,
    char const * from,
    char const * to,
    uint64_t value,
    uint64_t gas_limit,
    uint64_t gas_used,
    slice_ref_uint8_t input,
    char const * output,
    char const * error,
    char const * revert_reason);

typedef struct FfiSnifferResult FfiSnifferResult_t;

FfiSnifferResult_t * new_sniffer (void);

/** \brief
 *  Returns a pointer to C-like string or NULL if there is no error.
 */
char * sniffer_result_get_error_message (
    FfiSnifferResult_t const * result);

/** \brief
 *  Returns a pointer to `FfiSniffer` or NULL.
 *  Frees `result` arguments, so be sure to call `sniffer_result_get_error_message` to get an error message.
 */
FfiSniffer_t * sniffer_result_get_sniffer (
    FfiSnifferResult_t * result);

typedef struct FfiValue FfiValue_t;

typedef struct FfiValueData FfiValueData_t;

/** \brief
 *  Frees `value` argument.
 */
FfiValueData_t * new_value_data (
    FfiValue_t * value);

FfiValue_t * new_value_bool (
    bool data);

FfiValue_t * new_value_u64 (
    uint64_t data);

FfiValue_t * new_value_list (void);

/** \brief
 *  Returns `true` if success.
 *  Frees `data` argument.
 */
bool value_list_append (
    FfiValue_t * value_list,
    FfiValue_t * data);

FfiValue_t * new_value_struct (
    char const * ty);

/** \brief
 *  Returns `true` if success.
 *  Frees `data` argument.
 */
bool value_struct_add_field (
    FfiValue_t * value_struct,
    char const * key,
    FfiValue_t * data);

typedef struct FfiEvmBlockchainDataBuilder FfiEvmBlockchainDataBuilder_t;

FfiEvmBlockchainDataBuilder_t * new_evm_blockchain_data_builder (void);

void evm_blockchain_data_builder_set_tx (
    FfiEvmBlockchainDataBuilder_t * builder,
    char const * tx_id,
    char const * tx_hash);

void evm_blockchain_data_builder_set_block (
    FfiEvmBlockchainDataBuilder_t * builder,
    char const * block_id,
    char const * block_hash);

void evm_blockchain_data_builder_set_mempool_source (
    FfiEvmBlockchainDataBuilder_t * builder);

void evm_blockchain_data_builder_set_statistics (
    FfiEvmBlockchainDataBuilder_t * builder,
    uint64_t blocks,
    uint64_t transactions,
    uint64_t events,
    uint64_t call_traces);

typedef struct FfiEvmBlockchainDataCtx FfiEvmBlockchainDataCtx_t;

/** \brief
 *  Frees `builder` argument.
 */
FfiEvmBlockchainDataCtx_t * evm_blockchain_data_builder_finish (
    FfiEvmBlockchainDataBuilder_t * builder);

/** \brief
 *  Frees `data` argument.
 */
void evm_sniffer_observe_data (
    FfiSniffer_t const * sniffer,
    FfiEvmBlockchainDataCtx_t * data);

void evm_transaction_append (
    FfiEvmBlockchainDataBuilder_t * builder,
    uint32_t tx_index,
    char const * tx_hash,
    uint64_t block_index,
    uint8_t typ,
    uint64_t nonce,
    uint64_t status,
    char const * from,
    char const * to,
    uint64_t value,
    uint64_t fee,
    uint64_t gas_price,
    uint64_t gas_limit,
    uint64_t gas_used,
    slice_ref_uint8_t input,
    double size);

void evm_call_trace_append (
    FfiEvmBlockchainDataBuilder_t * builder,
    uint32_t seq,
    uint32_t depth,
    uint32_t tx_index,
    uint64_t block_index,
    char const * typ,
    char const * from,
    char const * to,
    uint64_t value,
    uint64_t gas_limit,
    uint64_t gas_used,
    slice_ref_uint8_t input);

void evm_block_set (
    FfiEvmBlockchainDataBuilder_t * builder,
    uint64_t block_index,
    char const * hash,
    char const * parent_hash,
    char const * state_root,
    uint64_t nonce,
    char const * status,
    uint64_t timestamp,
    slice_ref_uint8_t block_reward,
    char const * fee_recipient,
    uint64_t total_difficulty,
    double size,
    uint64_t gas_used,
    uint64_t gas_limit);

void evm_event_append (
    FfiEvmBlockchainDataBuilder_t * builder,
    uint32_t index,
    char const * address,
    uint64_t block_number,
    char const * tx_hash,
    uint32_t tx_index,
    char const * block_hash,
    slice_ref_uint8_t topic0,
    slice_ref_uint8_t topic1,
    slice_ref_uint8_t topic2,
    slice_ref_uint8_t topic3,
    slice_ref_uint8_t topic4,
    slice_ref_uint8_t data);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __RUST_MAMORU_SNIFFER_C__ */
