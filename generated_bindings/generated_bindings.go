// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 08 Mar 2023 12:10:11 CET.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated_bindings

/*
#cgo CFLAGS: -I${SRCDIR}/../packaged/include
#cgo LDFLAGS: -lmamoru_sniffer_go
#cgo darwin,arm64 LDFLAGS: -framework Security -L${SRCDIR}/../packaged/lib/darwin-arm64
#cgo linux,amd64 LDFLAGS: -Wl,--no-as-needed -ldl -lm -L${SRCDIR}/../packaged/lib/linux-amd64
#include <libmamoru_sniffer_go.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"unsafe"
)

// NewTransactionBatch function as declared in include/libmamoru_sniffer_go.h:19
func NewTransactionBatch() *FfiTransactionBatchT {
	__ret := C.new_transaction_batch()
	__v := *(**FfiTransactionBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// TransactionBatchAppend function as declared in include/libmamoru_sniffer_go.h:52
func TransactionBatchAppend(Batch *FfiTransactionBatchT, TxIndex uint32, TxHash string, BlockIndex uint64, Typ byte, Nonce uint64, Status uint64, From string, To string, Value uint64, Fee uint64, GasPrice uint64, GasLimit uint64, GasUsed uint64, Input SliceRefUint8T, Size float64) {
	cBatch, cBatchAllocMap := (*C.FfiTransactionBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cTxIndex, cTxIndexAllocMap := (C.uint32_t)(TxIndex), cgoAllocsUnknown
	TxHash = safeString(TxHash)
	cTxHash, cTxHashAllocMap := unpackPCharString(TxHash)
	cBlockIndex, cBlockIndexAllocMap := (C.uint64_t)(BlockIndex), cgoAllocsUnknown
	cTyp, cTypAllocMap := (C.uint8_t)(Typ), cgoAllocsUnknown
	cNonce, cNonceAllocMap := (C.uint64_t)(Nonce), cgoAllocsUnknown
	cStatus, cStatusAllocMap := (C.uint64_t)(Status), cgoAllocsUnknown
	From = safeString(From)
	cFrom, cFromAllocMap := unpackPCharString(From)
	To = safeString(To)
	cTo, cToAllocMap := unpackPCharString(To)
	cValue, cValueAllocMap := (C.uint64_t)(Value), cgoAllocsUnknown
	cFee, cFeeAllocMap := (C.uint64_t)(Fee), cgoAllocsUnknown
	cGasPrice, cGasPriceAllocMap := (C.uint64_t)(GasPrice), cgoAllocsUnknown
	cGasLimit, cGasLimitAllocMap := (C.uint64_t)(GasLimit), cgoAllocsUnknown
	cGasUsed, cGasUsedAllocMap := (C.uint64_t)(GasUsed), cgoAllocsUnknown
	cInput, cInputAllocMap := Input.PassValue()
	cSize, cSizeAllocMap := (C.double)(Size), cgoAllocsUnknown
	C.transaction_batch_append(cBatch, cTxIndex, cTxHash, cBlockIndex, cTyp, cNonce, cStatus, cFrom, cTo, cValue, cFee, cGasPrice, cGasLimit, cGasUsed, cInput, cSize)
	runtime.KeepAlive(cSizeAllocMap)
	runtime.KeepAlive(cInputAllocMap)
	runtime.KeepAlive(cGasUsedAllocMap)
	runtime.KeepAlive(cGasLimitAllocMap)
	runtime.KeepAlive(cGasPriceAllocMap)
	runtime.KeepAlive(cFeeAllocMap)
	runtime.KeepAlive(cValueAllocMap)
	runtime.KeepAlive(To)
	runtime.KeepAlive(cToAllocMap)
	runtime.KeepAlive(From)
	runtime.KeepAlive(cFromAllocMap)
	runtime.KeepAlive(cStatusAllocMap)
	runtime.KeepAlive(cNonceAllocMap)
	runtime.KeepAlive(cTypAllocMap)
	runtime.KeepAlive(cBlockIndexAllocMap)
	runtime.KeepAlive(TxHash)
	runtime.KeepAlive(cTxHashAllocMap)
	runtime.KeepAlive(cTxIndexAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// TransactionBatchFinish function as declared in include/libmamoru_sniffer_go.h:75
func TransactionBatchFinish(Object *FfiTransactionBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiTransactionBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.transaction_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewCallTraceBatch function as declared in include/libmamoru_sniffer_go.h:80
func NewCallTraceBatch() *FfiCallTraceBatchT {
	__ret := C.new_call_trace_batch()
	__v := *(**FfiCallTraceBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// CallTraceBatchAppend function as declared in include/libmamoru_sniffer_go.h:82
func CallTraceBatchAppend(Batch *FfiCallTraceBatchT, Seq uint32, Depth uint32, TxIndex uint32, BlockIndex uint64, Typ string, From string, To string, Value uint64, GasLimit uint64, GasUsed uint64, Input SliceRefUint8T) {
	cBatch, cBatchAllocMap := (*C.FfiCallTraceBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cSeq, cSeqAllocMap := (C.uint32_t)(Seq), cgoAllocsUnknown
	cDepth, cDepthAllocMap := (C.uint32_t)(Depth), cgoAllocsUnknown
	cTxIndex, cTxIndexAllocMap := (C.uint32_t)(TxIndex), cgoAllocsUnknown
	cBlockIndex, cBlockIndexAllocMap := (C.uint64_t)(BlockIndex), cgoAllocsUnknown
	Typ = safeString(Typ)
	cTyp, cTypAllocMap := unpackPCharString(Typ)
	From = safeString(From)
	cFrom, cFromAllocMap := unpackPCharString(From)
	To = safeString(To)
	cTo, cToAllocMap := unpackPCharString(To)
	cValue, cValueAllocMap := (C.uint64_t)(Value), cgoAllocsUnknown
	cGasLimit, cGasLimitAllocMap := (C.uint64_t)(GasLimit), cgoAllocsUnknown
	cGasUsed, cGasUsedAllocMap := (C.uint64_t)(GasUsed), cgoAllocsUnknown
	cInput, cInputAllocMap := Input.PassValue()
	C.call_trace_batch_append(cBatch, cSeq, cDepth, cTxIndex, cBlockIndex, cTyp, cFrom, cTo, cValue, cGasLimit, cGasUsed, cInput)
	runtime.KeepAlive(cInputAllocMap)
	runtime.KeepAlive(cGasUsedAllocMap)
	runtime.KeepAlive(cGasLimitAllocMap)
	runtime.KeepAlive(cValueAllocMap)
	runtime.KeepAlive(To)
	runtime.KeepAlive(cToAllocMap)
	runtime.KeepAlive(From)
	runtime.KeepAlive(cFromAllocMap)
	runtime.KeepAlive(Typ)
	runtime.KeepAlive(cTypAllocMap)
	runtime.KeepAlive(cBlockIndexAllocMap)
	runtime.KeepAlive(cTxIndexAllocMap)
	runtime.KeepAlive(cDepthAllocMap)
	runtime.KeepAlive(cSeqAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// CallTraceBatchFinish function as declared in include/libmamoru_sniffer_go.h:99
func CallTraceBatchFinish(Object *FfiCallTraceBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiCallTraceBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.call_trace_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewBlockBatch function as declared in include/libmamoru_sniffer_go.h:104
func NewBlockBatch() *FfiBlockBatchT {
	__ret := C.new_block_batch()
	__v := *(**FfiBlockBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// BlockBatchAppend function as declared in include/libmamoru_sniffer_go.h:106
func BlockBatchAppend(Batch *FfiBlockBatchT, BlockIndex uint64, Hash string, ParentHash string, StateRoot string, Nonce uint64, Status string, Timestamp uint64, BlockReward SliceRefUint8T, FeeRecipient string, TotalDifficulty uint64, Size float64, GasUsed uint64, GasLimit uint64) {
	cBatch, cBatchAllocMap := (*C.FfiBlockBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cBlockIndex, cBlockIndexAllocMap := (C.uint64_t)(BlockIndex), cgoAllocsUnknown
	Hash = safeString(Hash)
	cHash, cHashAllocMap := unpackPCharString(Hash)
	ParentHash = safeString(ParentHash)
	cParentHash, cParentHashAllocMap := unpackPCharString(ParentHash)
	StateRoot = safeString(StateRoot)
	cStateRoot, cStateRootAllocMap := unpackPCharString(StateRoot)
	cNonce, cNonceAllocMap := (C.uint64_t)(Nonce), cgoAllocsUnknown
	Status = safeString(Status)
	cStatus, cStatusAllocMap := unpackPCharString(Status)
	cTimestamp, cTimestampAllocMap := (C.uint64_t)(Timestamp), cgoAllocsUnknown
	cBlockReward, cBlockRewardAllocMap := BlockReward.PassValue()
	FeeRecipient = safeString(FeeRecipient)
	cFeeRecipient, cFeeRecipientAllocMap := unpackPCharString(FeeRecipient)
	cTotalDifficulty, cTotalDifficultyAllocMap := (C.uint64_t)(TotalDifficulty), cgoAllocsUnknown
	cSize, cSizeAllocMap := (C.double)(Size), cgoAllocsUnknown
	cGasUsed, cGasUsedAllocMap := (C.uint64_t)(GasUsed), cgoAllocsUnknown
	cGasLimit, cGasLimitAllocMap := (C.uint64_t)(GasLimit), cgoAllocsUnknown
	C.block_batch_append(cBatch, cBlockIndex, cHash, cParentHash, cStateRoot, cNonce, cStatus, cTimestamp, cBlockReward, cFeeRecipient, cTotalDifficulty, cSize, cGasUsed, cGasLimit)
	runtime.KeepAlive(cGasLimitAllocMap)
	runtime.KeepAlive(cGasUsedAllocMap)
	runtime.KeepAlive(cSizeAllocMap)
	runtime.KeepAlive(cTotalDifficultyAllocMap)
	runtime.KeepAlive(FeeRecipient)
	runtime.KeepAlive(cFeeRecipientAllocMap)
	runtime.KeepAlive(cBlockRewardAllocMap)
	runtime.KeepAlive(cTimestampAllocMap)
	runtime.KeepAlive(Status)
	runtime.KeepAlive(cStatusAllocMap)
	runtime.KeepAlive(cNonceAllocMap)
	runtime.KeepAlive(StateRoot)
	runtime.KeepAlive(cStateRootAllocMap)
	runtime.KeepAlive(ParentHash)
	runtime.KeepAlive(cParentHashAllocMap)
	runtime.KeepAlive(Hash)
	runtime.KeepAlive(cHashAllocMap)
	runtime.KeepAlive(cBlockIndexAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// BlockBatchFinish function as declared in include/libmamoru_sniffer_go.h:125
func BlockBatchFinish(Object *FfiBlockBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiBlockBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.block_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewEventBatch function as declared in include/libmamoru_sniffer_go.h:130
func NewEventBatch() *FfiEventBatchT {
	__ret := C.new_event_batch()
	__v := *(**FfiEventBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// EventBatchAppend function as declared in include/libmamoru_sniffer_go.h:132
func EventBatchAppend(Batch *FfiEventBatchT, Index uint32, Address string, BlockNumber uint64, TxHash string, TxIndex uint32, BlockHash string, Topic0 SliceRefUint8T, Topic1 SliceRefUint8T, Topic2 SliceRefUint8T, Topic3 SliceRefUint8T, Topic4 SliceRefUint8T, Data SliceRefUint8T) {
	cBatch, cBatchAllocMap := (*C.FfiEventBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cIndex, cIndexAllocMap := (C.uint32_t)(Index), cgoAllocsUnknown
	Address = safeString(Address)
	cAddress, cAddressAllocMap := unpackPCharString(Address)
	cBlockNumber, cBlockNumberAllocMap := (C.uint64_t)(BlockNumber), cgoAllocsUnknown
	TxHash = safeString(TxHash)
	cTxHash, cTxHashAllocMap := unpackPCharString(TxHash)
	cTxIndex, cTxIndexAllocMap := (C.uint32_t)(TxIndex), cgoAllocsUnknown
	BlockHash = safeString(BlockHash)
	cBlockHash, cBlockHashAllocMap := unpackPCharString(BlockHash)
	cTopic0, cTopic0AllocMap := Topic0.PassValue()
	cTopic1, cTopic1AllocMap := Topic1.PassValue()
	cTopic2, cTopic2AllocMap := Topic2.PassValue()
	cTopic3, cTopic3AllocMap := Topic3.PassValue()
	cTopic4, cTopic4AllocMap := Topic4.PassValue()
	cData, cDataAllocMap := Data.PassValue()
	C.event_batch_append(cBatch, cIndex, cAddress, cBlockNumber, cTxHash, cTxIndex, cBlockHash, cTopic0, cTopic1, cTopic2, cTopic3, cTopic4, cData)
	runtime.KeepAlive(cDataAllocMap)
	runtime.KeepAlive(cTopic4AllocMap)
	runtime.KeepAlive(cTopic3AllocMap)
	runtime.KeepAlive(cTopic2AllocMap)
	runtime.KeepAlive(cTopic1AllocMap)
	runtime.KeepAlive(cTopic0AllocMap)
	runtime.KeepAlive(BlockHash)
	runtime.KeepAlive(cBlockHashAllocMap)
	runtime.KeepAlive(cTxIndexAllocMap)
	runtime.KeepAlive(TxHash)
	runtime.KeepAlive(cTxHashAllocMap)
	runtime.KeepAlive(cBlockNumberAllocMap)
	runtime.KeepAlive(Address)
	runtime.KeepAlive(cAddressAllocMap)
	runtime.KeepAlive(cIndexAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// EventBatchFinish function as declared in include/libmamoru_sniffer_go.h:150
func EventBatchFinish(Object *FfiEventBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiEventBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.event_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewSniffer function as declared in include/libmamoru_sniffer_go.h:155
func NewSniffer() *FfiSnifferResultT {
	__ret := C.new_sniffer()
	__v := *(**FfiSnifferResultT)(unsafe.Pointer(&__ret))
	return __v
}

// SnifferResultGetErrorMessage function as declared in include/libmamoru_sniffer_go.h:160
func SnifferResultGetErrorMessage(Result *FfiSnifferResultT) *byte {
	cResult, cResultAllocMap := (*C.FfiSnifferResult_t)(unsafe.Pointer(Result)), cgoAllocsUnknown
	__ret := C.sniffer_result_get_error_message(cResult)
	runtime.KeepAlive(cResultAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// SnifferResultGetSniffer function as declared in include/libmamoru_sniffer_go.h:169
func SnifferResultGetSniffer(Result *FfiSnifferResultT) *FfiSnifferT {
	cResult, cResultAllocMap := (*C.FfiSnifferResult_t)(unsafe.Pointer(Result)), cgoAllocsUnknown
	__ret := C.sniffer_result_get_sniffer(cResult)
	runtime.KeepAlive(cResultAllocMap)
	__v := *(**FfiSnifferT)(unsafe.Pointer(&__ret))
	return __v
}

// SnifferObserveData function as declared in include/libmamoru_sniffer_go.h:177
func SnifferObserveData(Sniffer *FfiSnifferT, Data *FfiBlockchainDataCtxT) {
	cSniffer, cSnifferAllocMap := (*C.FfiSniffer_t)(unsafe.Pointer(Sniffer)), cgoAllocsUnknown
	cData, cDataAllocMap := (*C.FfiBlockchainDataCtx_t)(unsafe.Pointer(Data)), cgoAllocsUnknown
	C.sniffer_observe_data(cSniffer, cData)
	runtime.KeepAlive(cDataAllocMap)
	runtime.KeepAlive(cSnifferAllocMap)
}

// NewBlockchainDataCtxBuilder function as declared in include/libmamoru_sniffer_go.h:183
func NewBlockchainDataCtxBuilder() *FfiBlockchainDataCtxBuilderT {
	__ret := C.new_blockchain_data_ctx_builder()
	__v := *(**FfiBlockchainDataCtxBuilderT)(unsafe.Pointer(&__ret))
	return __v
}

// BlockchainDataCtxBuilderAddData function as declared in include/libmamoru_sniffer_go.h:192
func BlockchainDataCtxBuilderAddData(Builder *FfiBlockchainDataCtxBuilderT, Data *FfiBlockchainDataT) bool {
	cBuilder, cBuilderAllocMap := (*C.FfiBlockchainDataCtxBuilder_t)(unsafe.Pointer(Builder)), cgoAllocsUnknown
	cData, cDataAllocMap := (*C.FfiBlockchainData_t)(unsafe.Pointer(Data)), cgoAllocsUnknown
	__ret := C.blockchain_data_ctx_builder_add_data(cBuilder, cData)
	runtime.KeepAlive(cDataAllocMap)
	runtime.KeepAlive(cBuilderAllocMap)
	__v := (bool)(__ret)
	return __v
}

// BlockchainDataCtxBuilderFinish function as declared in include/libmamoru_sniffer_go.h:196
func BlockchainDataCtxBuilderFinish(Builder *FfiBlockchainDataCtxBuilderT, TxId string, TxHash string) *FfiBlockchainDataCtxT {
	cBuilder, cBuilderAllocMap := (*C.FfiBlockchainDataCtxBuilder_t)(unsafe.Pointer(Builder)), cgoAllocsUnknown
	TxId = safeString(TxId)
	cTxId, cTxIdAllocMap := unpackPCharString(TxId)
	TxHash = safeString(TxHash)
	cTxHash, cTxHashAllocMap := unpackPCharString(TxHash)
	__ret := C.blockchain_data_ctx_builder_finish(cBuilder, cTxId, cTxHash)
	runtime.KeepAlive(TxHash)
	runtime.KeepAlive(cTxHashAllocMap)
	runtime.KeepAlive(TxId)
	runtime.KeepAlive(cTxIdAllocMap)
	runtime.KeepAlive(cBuilderAllocMap)
	__v := *(**FfiBlockchainDataCtxT)(unsafe.Pointer(&__ret))
	return __v
}

// NewValueData function as declared in include/libmamoru_sniffer_go.h:208
func NewValueData(Value *FfiValueT) *FfiValueDataT {
	cValue, cValueAllocMap := (*C.FfiValue_t)(unsafe.Pointer(Value)), cgoAllocsUnknown
	__ret := C.new_value_data(cValue)
	runtime.KeepAlive(cValueAllocMap)
	__v := *(**FfiValueDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewValueBool function as declared in include/libmamoru_sniffer_go.h:211
func NewValueBool(Data bool) *FfiValueT {
	cData, cDataAllocMap := (C._Bool)(Data), cgoAllocsUnknown
	__ret := C.new_value_bool(cData)
	runtime.KeepAlive(cDataAllocMap)
	__v := *(**FfiValueT)(unsafe.Pointer(&__ret))
	return __v
}

// NewValueU64 function as declared in include/libmamoru_sniffer_go.h:214
func NewValueU64(Data uint64) *FfiValueT {
	cData, cDataAllocMap := (C.uint64_t)(Data), cgoAllocsUnknown
	__ret := C.new_value_u64(cData)
	runtime.KeepAlive(cDataAllocMap)
	__v := *(**FfiValueT)(unsafe.Pointer(&__ret))
	return __v
}

// NewValueList function as declared in include/libmamoru_sniffer_go.h:217
func NewValueList() *FfiValueT {
	__ret := C.new_value_list()
	__v := *(**FfiValueT)(unsafe.Pointer(&__ret))
	return __v
}

// ValueListAppend function as declared in include/libmamoru_sniffer_go.h:223
func ValueListAppend(ValueList *FfiValueT, Data *FfiValueT) bool {
	cValueList, cValueListAllocMap := (*C.FfiValue_t)(unsafe.Pointer(ValueList)), cgoAllocsUnknown
	cData, cDataAllocMap := (*C.FfiValue_t)(unsafe.Pointer(Data)), cgoAllocsUnknown
	__ret := C.value_list_append(cValueList, cData)
	runtime.KeepAlive(cDataAllocMap)
	runtime.KeepAlive(cValueListAllocMap)
	__v := (bool)(__ret)
	return __v
}

// NewValueStruct function as declared in include/libmamoru_sniffer_go.h:227
func NewValueStruct(Ty string) *FfiValueT {
	Ty = safeString(Ty)
	cTy, cTyAllocMap := unpackPCharString(Ty)
	__ret := C.new_value_struct(cTy)
	runtime.KeepAlive(Ty)
	runtime.KeepAlive(cTyAllocMap)
	__v := *(**FfiValueT)(unsafe.Pointer(&__ret))
	return __v
}

// ValueStructAddField function as declared in include/libmamoru_sniffer_go.h:234
func ValueStructAddField(ValueStruct *FfiValueT, Key string, Data *FfiValueT) bool {
	cValueStruct, cValueStructAllocMap := (*C.FfiValue_t)(unsafe.Pointer(ValueStruct)), cgoAllocsUnknown
	Key = safeString(Key)
	cKey, cKeyAllocMap := unpackPCharString(Key)
	cData, cDataAllocMap := (*C.FfiValue_t)(unsafe.Pointer(Data)), cgoAllocsUnknown
	__ret := C.value_struct_add_field(cValueStruct, cKey, cData)
	runtime.KeepAlive(cDataAllocMap)
	runtime.KeepAlive(Key)
	runtime.KeepAlive(cKeyAllocMap)
	runtime.KeepAlive(cValueStructAllocMap)
	__v := (bool)(__ret)
	return __v
}
