// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Thu, 26 Jan 2023 16:39:17 CET.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated_bindings

/*
#cgo CFLAGS: -I${SRCDIR}/../packaged/include
#cgo LDFLAGS: -lmamoru_sniffer_go
#cgo darwin,arm64 LDFLAGS: -framework Security -L${SRCDIR}/../packaged/lib/darwin-arm64
#cgo linux,amd64 LDFLAGS: -Wl,--no-as-needed -ldl -lm -L${SRCDIR}/../packaged/lib/linux-amd64
#include <libmamoru_sniffer_go.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"unsafe"
)

// NewTransactionBatch function as declared in include/libmamoru_sniffer_go.h:19
func NewTransactionBatch() *FfiTransactionBatchT {
	__ret := C.new_transaction_batch()
	__v := *(**FfiTransactionBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// TransactionBatchAppend function as declared in include/libmamoru_sniffer_go.h:25
func TransactionBatchAppend(Batch *FfiTransactionBatchT, TxIndex uint32, TxHash string, BlockIndex uint64, Typ byte, Nonce uint64, Status uint64, Timestamp uint64, From string, To string, Value uint64, Fee uint64, GasPrice uint64, GasLimit uint64, GasUsed uint64, Method string, Size float64) {
	cBatch, cBatchAllocMap := (*C.FfiTransactionBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cTxIndex, cTxIndexAllocMap := (C.uint32_t)(TxIndex), cgoAllocsUnknown
	TxHash = safeString(TxHash)
	cTxHash, cTxHashAllocMap := unpackPCharString(TxHash)
	cBlockIndex, cBlockIndexAllocMap := (C.uint64_t)(BlockIndex), cgoAllocsUnknown
	cTyp, cTypAllocMap := (C.uint8_t)(Typ), cgoAllocsUnknown
	cNonce, cNonceAllocMap := (C.uint64_t)(Nonce), cgoAllocsUnknown
	cStatus, cStatusAllocMap := (C.uint64_t)(Status), cgoAllocsUnknown
	cTimestamp, cTimestampAllocMap := (C.uint64_t)(Timestamp), cgoAllocsUnknown
	From = safeString(From)
	cFrom, cFromAllocMap := unpackPCharString(From)
	To = safeString(To)
	cTo, cToAllocMap := unpackPCharString(To)
	cValue, cValueAllocMap := (C.uint64_t)(Value), cgoAllocsUnknown
	cFee, cFeeAllocMap := (C.uint64_t)(Fee), cgoAllocsUnknown
	cGasPrice, cGasPriceAllocMap := (C.uint64_t)(GasPrice), cgoAllocsUnknown
	cGasLimit, cGasLimitAllocMap := (C.uint64_t)(GasLimit), cgoAllocsUnknown
	cGasUsed, cGasUsedAllocMap := (C.uint64_t)(GasUsed), cgoAllocsUnknown
	Method = safeString(Method)
	cMethod, cMethodAllocMap := unpackPCharString(Method)
	cSize, cSizeAllocMap := (C.double)(Size), cgoAllocsUnknown
	C.transaction_batch_append(cBatch, cTxIndex, cTxHash, cBlockIndex, cTyp, cNonce, cStatus, cTimestamp, cFrom, cTo, cValue, cFee, cGasPrice, cGasLimit, cGasUsed, cMethod, cSize)
	runtime.KeepAlive(cSizeAllocMap)
	runtime.KeepAlive(Method)
	runtime.KeepAlive(cMethodAllocMap)
	runtime.KeepAlive(cGasUsedAllocMap)
	runtime.KeepAlive(cGasLimitAllocMap)
	runtime.KeepAlive(cGasPriceAllocMap)
	runtime.KeepAlive(cFeeAllocMap)
	runtime.KeepAlive(cValueAllocMap)
	runtime.KeepAlive(To)
	runtime.KeepAlive(cToAllocMap)
	runtime.KeepAlive(From)
	runtime.KeepAlive(cFromAllocMap)
	runtime.KeepAlive(cTimestampAllocMap)
	runtime.KeepAlive(cStatusAllocMap)
	runtime.KeepAlive(cNonceAllocMap)
	runtime.KeepAlive(cTypAllocMap)
	runtime.KeepAlive(cBlockIndexAllocMap)
	runtime.KeepAlive(TxHash)
	runtime.KeepAlive(cTxHashAllocMap)
	runtime.KeepAlive(cTxIndexAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// TransactionBatchFinish function as declared in include/libmamoru_sniffer_go.h:49
func TransactionBatchFinish(Object *FfiTransactionBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiTransactionBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.transaction_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewTransactionArgBatch function as declared in include/libmamoru_sniffer_go.h:54
func NewTransactionArgBatch() *FfiTransactionArgBatchT {
	__ret := C.new_transaction_arg_batch()
	__v := *(**FfiTransactionArgBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// TransactionArgBatchAppend function as declared in include/libmamoru_sniffer_go.h:56
func TransactionArgBatchAppend(Batch *FfiTransactionArgBatchT, TxIndex uint32, Arg string) {
	cBatch, cBatchAllocMap := (*C.FfiTransactionArgBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cTxIndex, cTxIndexAllocMap := (C.uint32_t)(TxIndex), cgoAllocsUnknown
	Arg = safeString(Arg)
	cArg, cArgAllocMap := unpackPCharString(Arg)
	C.transaction_arg_batch_append(cBatch, cTxIndex, cArg)
	runtime.KeepAlive(Arg)
	runtime.KeepAlive(cArgAllocMap)
	runtime.KeepAlive(cTxIndexAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// TransactionArgBatchFinish function as declared in include/libmamoru_sniffer_go.h:64
func TransactionArgBatchFinish(Object *FfiTransactionArgBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiTransactionArgBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.transaction_arg_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewCallTraceBatch function as declared in include/libmamoru_sniffer_go.h:69
func NewCallTraceBatch() *FfiCallTraceBatchT {
	__ret := C.new_call_trace_batch()
	__v := *(**FfiCallTraceBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// CallTraceBatchAppend function as declared in include/libmamoru_sniffer_go.h:71
func CallTraceBatchAppend(Batch *FfiCallTraceBatchT, Seq uint32, Depth uint32, TxIndex uint32, BlockIndex uint64, Typ string, From string, To string, Value uint64, GasLimit uint64, GasUsed uint64, MethodId string) {
	cBatch, cBatchAllocMap := (*C.FfiCallTraceBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cSeq, cSeqAllocMap := (C.uint32_t)(Seq), cgoAllocsUnknown
	cDepth, cDepthAllocMap := (C.uint32_t)(Depth), cgoAllocsUnknown
	cTxIndex, cTxIndexAllocMap := (C.uint32_t)(TxIndex), cgoAllocsUnknown
	cBlockIndex, cBlockIndexAllocMap := (C.uint64_t)(BlockIndex), cgoAllocsUnknown
	Typ = safeString(Typ)
	cTyp, cTypAllocMap := unpackPCharString(Typ)
	From = safeString(From)
	cFrom, cFromAllocMap := unpackPCharString(From)
	To = safeString(To)
	cTo, cToAllocMap := unpackPCharString(To)
	cValue, cValueAllocMap := (C.uint64_t)(Value), cgoAllocsUnknown
	cGasLimit, cGasLimitAllocMap := (C.uint64_t)(GasLimit), cgoAllocsUnknown
	cGasUsed, cGasUsedAllocMap := (C.uint64_t)(GasUsed), cgoAllocsUnknown
	MethodId = safeString(MethodId)
	cMethodId, cMethodIdAllocMap := unpackPCharString(MethodId)
	C.call_trace_batch_append(cBatch, cSeq, cDepth, cTxIndex, cBlockIndex, cTyp, cFrom, cTo, cValue, cGasLimit, cGasUsed, cMethodId)
	runtime.KeepAlive(MethodId)
	runtime.KeepAlive(cMethodIdAllocMap)
	runtime.KeepAlive(cGasUsedAllocMap)
	runtime.KeepAlive(cGasLimitAllocMap)
	runtime.KeepAlive(cValueAllocMap)
	runtime.KeepAlive(To)
	runtime.KeepAlive(cToAllocMap)
	runtime.KeepAlive(From)
	runtime.KeepAlive(cFromAllocMap)
	runtime.KeepAlive(Typ)
	runtime.KeepAlive(cTypAllocMap)
	runtime.KeepAlive(cBlockIndexAllocMap)
	runtime.KeepAlive(cTxIndexAllocMap)
	runtime.KeepAlive(cDepthAllocMap)
	runtime.KeepAlive(cSeqAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// CallTraceBatchFinish function as declared in include/libmamoru_sniffer_go.h:88
func CallTraceBatchFinish(Object *FfiCallTraceBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiCallTraceBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.call_trace_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewCallTraceArgBatch function as declared in include/libmamoru_sniffer_go.h:93
func NewCallTraceArgBatch() *FfiCallTraceArgBatchT {
	__ret := C.new_call_trace_arg_batch()
	__v := *(**FfiCallTraceArgBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// CallTraceArgBatchAppend function as declared in include/libmamoru_sniffer_go.h:95
func CallTraceArgBatchAppend(Batch *FfiCallTraceArgBatchT, CallTraceSeq uint32, TxIndex uint32, BlockIndex uint64, Arg string) {
	cBatch, cBatchAllocMap := (*C.FfiCallTraceArgBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cCallTraceSeq, cCallTraceSeqAllocMap := (C.uint32_t)(CallTraceSeq), cgoAllocsUnknown
	cTxIndex, cTxIndexAllocMap := (C.uint32_t)(TxIndex), cgoAllocsUnknown
	cBlockIndex, cBlockIndexAllocMap := (C.uint64_t)(BlockIndex), cgoAllocsUnknown
	Arg = safeString(Arg)
	cArg, cArgAllocMap := unpackPCharString(Arg)
	C.call_trace_arg_batch_append(cBatch, cCallTraceSeq, cTxIndex, cBlockIndex, cArg)
	runtime.KeepAlive(Arg)
	runtime.KeepAlive(cArgAllocMap)
	runtime.KeepAlive(cBlockIndexAllocMap)
	runtime.KeepAlive(cTxIndexAllocMap)
	runtime.KeepAlive(cCallTraceSeqAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// CallTraceArgBatchFinish function as declared in include/libmamoru_sniffer_go.h:105
func CallTraceArgBatchFinish(Object *FfiCallTraceArgBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiCallTraceArgBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.call_trace_arg_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewBlockBatch function as declared in include/libmamoru_sniffer_go.h:110
func NewBlockBatch() *FfiBlockBatchT {
	__ret := C.new_block_batch()
	__v := *(**FfiBlockBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// BlockBatchAppend function as declared in include/libmamoru_sniffer_go.h:139
func BlockBatchAppend(Batch *FfiBlockBatchT, BlockIndex uint64, Hash string, ParentHash string, StateRoot string, Nonce uint64, Status string, Timestamp uint64, BlockReward SliceRefUint8T, FeeRecipient string, TotalDifficulty uint64, Size float64, GasUsed uint64, GasLimit uint64, BurntFees SliceRefUint8T, PosProposedOnTime uint32, PosSlot uint32, PosEpoch uint32, PosProposerIndex uint32, PosSlotRootHash SliceRefUint8T, PosBeaconChainDepositCount uint32, PosSlotGraffiti SliceRefUint8T, PosBlockRandomness SliceRefUint8T, PosRandomReveal SliceRefUint8T) {
	cBatch, cBatchAllocMap := (*C.FfiBlockBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cBlockIndex, cBlockIndexAllocMap := (C.uint64_t)(BlockIndex), cgoAllocsUnknown
	Hash = safeString(Hash)
	cHash, cHashAllocMap := unpackPCharString(Hash)
	ParentHash = safeString(ParentHash)
	cParentHash, cParentHashAllocMap := unpackPCharString(ParentHash)
	StateRoot = safeString(StateRoot)
	cStateRoot, cStateRootAllocMap := unpackPCharString(StateRoot)
	cNonce, cNonceAllocMap := (C.uint64_t)(Nonce), cgoAllocsUnknown
	Status = safeString(Status)
	cStatus, cStatusAllocMap := unpackPCharString(Status)
	cTimestamp, cTimestampAllocMap := (C.uint64_t)(Timestamp), cgoAllocsUnknown
	cBlockReward, cBlockRewardAllocMap := BlockReward.PassValue()
	FeeRecipient = safeString(FeeRecipient)
	cFeeRecipient, cFeeRecipientAllocMap := unpackPCharString(FeeRecipient)
	cTotalDifficulty, cTotalDifficultyAllocMap := (C.uint64_t)(TotalDifficulty), cgoAllocsUnknown
	cSize, cSizeAllocMap := (C.double)(Size), cgoAllocsUnknown
	cGasUsed, cGasUsedAllocMap := (C.uint64_t)(GasUsed), cgoAllocsUnknown
	cGasLimit, cGasLimitAllocMap := (C.uint64_t)(GasLimit), cgoAllocsUnknown
	cBurntFees, cBurntFeesAllocMap := BurntFees.PassValue()
	cPosProposedOnTime, cPosProposedOnTimeAllocMap := (C.uint32_t)(PosProposedOnTime), cgoAllocsUnknown
	cPosSlot, cPosSlotAllocMap := (C.uint32_t)(PosSlot), cgoAllocsUnknown
	cPosEpoch, cPosEpochAllocMap := (C.uint32_t)(PosEpoch), cgoAllocsUnknown
	cPosProposerIndex, cPosProposerIndexAllocMap := (C.uint32_t)(PosProposerIndex), cgoAllocsUnknown
	cPosSlotRootHash, cPosSlotRootHashAllocMap := PosSlotRootHash.PassValue()
	cPosBeaconChainDepositCount, cPosBeaconChainDepositCountAllocMap := (C.uint32_t)(PosBeaconChainDepositCount), cgoAllocsUnknown
	cPosSlotGraffiti, cPosSlotGraffitiAllocMap := PosSlotGraffiti.PassValue()
	cPosBlockRandomness, cPosBlockRandomnessAllocMap := PosBlockRandomness.PassValue()
	cPosRandomReveal, cPosRandomRevealAllocMap := PosRandomReveal.PassValue()
	C.block_batch_append(cBatch, cBlockIndex, cHash, cParentHash, cStateRoot, cNonce, cStatus, cTimestamp, cBlockReward, cFeeRecipient, cTotalDifficulty, cSize, cGasUsed, cGasLimit, cBurntFees, cPosProposedOnTime, cPosSlot, cPosEpoch, cPosProposerIndex, cPosSlotRootHash, cPosBeaconChainDepositCount, cPosSlotGraffiti, cPosBlockRandomness, cPosRandomReveal)
	runtime.KeepAlive(cPosRandomRevealAllocMap)
	runtime.KeepAlive(cPosBlockRandomnessAllocMap)
	runtime.KeepAlive(cPosSlotGraffitiAllocMap)
	runtime.KeepAlive(cPosBeaconChainDepositCountAllocMap)
	runtime.KeepAlive(cPosSlotRootHashAllocMap)
	runtime.KeepAlive(cPosProposerIndexAllocMap)
	runtime.KeepAlive(cPosEpochAllocMap)
	runtime.KeepAlive(cPosSlotAllocMap)
	runtime.KeepAlive(cPosProposedOnTimeAllocMap)
	runtime.KeepAlive(cBurntFeesAllocMap)
	runtime.KeepAlive(cGasLimitAllocMap)
	runtime.KeepAlive(cGasUsedAllocMap)
	runtime.KeepAlive(cSizeAllocMap)
	runtime.KeepAlive(cTotalDifficultyAllocMap)
	runtime.KeepAlive(FeeRecipient)
	runtime.KeepAlive(cFeeRecipientAllocMap)
	runtime.KeepAlive(cBlockRewardAllocMap)
	runtime.KeepAlive(cTimestampAllocMap)
	runtime.KeepAlive(Status)
	runtime.KeepAlive(cStatusAllocMap)
	runtime.KeepAlive(cNonceAllocMap)
	runtime.KeepAlive(StateRoot)
	runtime.KeepAlive(cStateRootAllocMap)
	runtime.KeepAlive(ParentHash)
	runtime.KeepAlive(cParentHashAllocMap)
	runtime.KeepAlive(Hash)
	runtime.KeepAlive(cHashAllocMap)
	runtime.KeepAlive(cBlockIndexAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// BlockBatchFinish function as declared in include/libmamoru_sniffer_go.h:168
func BlockBatchFinish(Object *FfiBlockBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiBlockBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.block_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewEventBatch function as declared in include/libmamoru_sniffer_go.h:173
func NewEventBatch() *FfiEventBatchT {
	__ret := C.new_event_batch()
	__v := *(**FfiEventBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// EventBatchAppend function as declared in include/libmamoru_sniffer_go.h:175
func EventBatchAppend(Batch *FfiEventBatchT, Index uint32, Address string, Data SliceRefUint8T, BlockNumber uint64, TxHash string, TxIndex uint32, BlockHash string) {
	cBatch, cBatchAllocMap := (*C.FfiEventBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cIndex, cIndexAllocMap := (C.uint32_t)(Index), cgoAllocsUnknown
	Address = safeString(Address)
	cAddress, cAddressAllocMap := unpackPCharString(Address)
	cData, cDataAllocMap := Data.PassValue()
	cBlockNumber, cBlockNumberAllocMap := (C.uint64_t)(BlockNumber), cgoAllocsUnknown
	TxHash = safeString(TxHash)
	cTxHash, cTxHashAllocMap := unpackPCharString(TxHash)
	cTxIndex, cTxIndexAllocMap := (C.uint32_t)(TxIndex), cgoAllocsUnknown
	BlockHash = safeString(BlockHash)
	cBlockHash, cBlockHashAllocMap := unpackPCharString(BlockHash)
	C.event_batch_append(cBatch, cIndex, cAddress, cData, cBlockNumber, cTxHash, cTxIndex, cBlockHash)
	runtime.KeepAlive(BlockHash)
	runtime.KeepAlive(cBlockHashAllocMap)
	runtime.KeepAlive(cTxIndexAllocMap)
	runtime.KeepAlive(TxHash)
	runtime.KeepAlive(cTxHashAllocMap)
	runtime.KeepAlive(cBlockNumberAllocMap)
	runtime.KeepAlive(cDataAllocMap)
	runtime.KeepAlive(Address)
	runtime.KeepAlive(cAddressAllocMap)
	runtime.KeepAlive(cIndexAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// EventBatchFinish function as declared in include/libmamoru_sniffer_go.h:188
func EventBatchFinish(Object *FfiEventBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiEventBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.event_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewEventTopicBatch function as declared in include/libmamoru_sniffer_go.h:193
func NewEventTopicBatch() *FfiEventTopicBatchT {
	__ret := C.new_event_topic_batch()
	__v := *(**FfiEventTopicBatchT)(unsafe.Pointer(&__ret))
	return __v
}

// EventTopicBatchAppend function as declared in include/libmamoru_sniffer_go.h:195
func EventTopicBatchAppend(Batch *FfiEventTopicBatchT, EventIndex uint32, Topic string) {
	cBatch, cBatchAllocMap := (*C.FfiEventTopicBatch_t)(unsafe.Pointer(Batch)), cgoAllocsUnknown
	cEventIndex, cEventIndexAllocMap := (C.uint32_t)(EventIndex), cgoAllocsUnknown
	Topic = safeString(Topic)
	cTopic, cTopicAllocMap := unpackPCharString(Topic)
	C.event_topic_batch_append(cBatch, cEventIndex, cTopic)
	runtime.KeepAlive(Topic)
	runtime.KeepAlive(cTopicAllocMap)
	runtime.KeepAlive(cEventIndexAllocMap)
	runtime.KeepAlive(cBatchAllocMap)
}

// EventTopicBatchFinish function as declared in include/libmamoru_sniffer_go.h:203
func EventTopicBatchFinish(Object *FfiEventTopicBatchT) *FfiBlockchainDataT {
	cObject, cObjectAllocMap := (*C.FfiEventTopicBatch_t)(unsafe.Pointer(Object)), cgoAllocsUnknown
	__ret := C.event_topic_batch_finish(cObject)
	runtime.KeepAlive(cObjectAllocMap)
	__v := *(**FfiBlockchainDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewSniffer function as declared in include/libmamoru_sniffer_go.h:208
func NewSniffer() *FfiSnifferResultT {
	__ret := C.new_sniffer()
	__v := *(**FfiSnifferResultT)(unsafe.Pointer(&__ret))
	return __v
}

// SnifferResultGetErrorMessage function as declared in include/libmamoru_sniffer_go.h:213
func SnifferResultGetErrorMessage(Result *FfiSnifferResultT) *byte {
	cResult, cResultAllocMap := (*C.FfiSnifferResult_t)(unsafe.Pointer(Result)), cgoAllocsUnknown
	__ret := C.sniffer_result_get_error_message(cResult)
	runtime.KeepAlive(cResultAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// SnifferResultGetSniffer function as declared in include/libmamoru_sniffer_go.h:222
func SnifferResultGetSniffer(Result *FfiSnifferResultT) *FfiSnifferT {
	cResult, cResultAllocMap := (*C.FfiSnifferResult_t)(unsafe.Pointer(Result)), cgoAllocsUnknown
	__ret := C.sniffer_result_get_sniffer(cResult)
	runtime.KeepAlive(cResultAllocMap)
	__v := *(**FfiSnifferT)(unsafe.Pointer(&__ret))
	return __v
}

// SnifferObserveData function as declared in include/libmamoru_sniffer_go.h:230
func SnifferObserveData(Sniffer *FfiSnifferT, Data *FfiBlockchainDataCtxT) {
	cSniffer, cSnifferAllocMap := (*C.FfiSniffer_t)(unsafe.Pointer(Sniffer)), cgoAllocsUnknown
	cData, cDataAllocMap := (*C.FfiBlockchainDataCtx_t)(unsafe.Pointer(Data)), cgoAllocsUnknown
	C.sniffer_observe_data(cSniffer, cData)
	runtime.KeepAlive(cDataAllocMap)
	runtime.KeepAlive(cSnifferAllocMap)
}

// NewBlockchainDataCtxBuilder function as declared in include/libmamoru_sniffer_go.h:236
func NewBlockchainDataCtxBuilder() *FfiBlockchainDataCtxBuilderT {
	__ret := C.new_blockchain_data_ctx_builder()
	__v := *(**FfiBlockchainDataCtxBuilderT)(unsafe.Pointer(&__ret))
	return __v
}

// BlockchainDataCtxBuilderAddData function as declared in include/libmamoru_sniffer_go.h:245
func BlockchainDataCtxBuilderAddData(Builder *FfiBlockchainDataCtxBuilderT, Data *FfiBlockchainDataT) bool {
	cBuilder, cBuilderAllocMap := (*C.FfiBlockchainDataCtxBuilder_t)(unsafe.Pointer(Builder)), cgoAllocsUnknown
	cData, cDataAllocMap := (*C.FfiBlockchainData_t)(unsafe.Pointer(Data)), cgoAllocsUnknown
	__ret := C.blockchain_data_ctx_builder_add_data(cBuilder, cData)
	runtime.KeepAlive(cDataAllocMap)
	runtime.KeepAlive(cBuilderAllocMap)
	__v := (bool)(__ret)
	return __v
}

// BlockchainDataCtxBuilderFinish function as declared in include/libmamoru_sniffer_go.h:249
func BlockchainDataCtxBuilderFinish(Builder *FfiBlockchainDataCtxBuilderT, TxId string, TxHash string, TxTimestampSecs int64) *FfiBlockchainDataCtxT {
	cBuilder, cBuilderAllocMap := (*C.FfiBlockchainDataCtxBuilder_t)(unsafe.Pointer(Builder)), cgoAllocsUnknown
	TxId = safeString(TxId)
	cTxId, cTxIdAllocMap := unpackPCharString(TxId)
	TxHash = safeString(TxHash)
	cTxHash, cTxHashAllocMap := unpackPCharString(TxHash)
	cTxTimestampSecs, cTxTimestampSecsAllocMap := (C.int64_t)(TxTimestampSecs), cgoAllocsUnknown
	__ret := C.blockchain_data_ctx_builder_finish(cBuilder, cTxId, cTxHash, cTxTimestampSecs)
	runtime.KeepAlive(cTxTimestampSecsAllocMap)
	runtime.KeepAlive(TxHash)
	runtime.KeepAlive(cTxHashAllocMap)
	runtime.KeepAlive(TxId)
	runtime.KeepAlive(cTxIdAllocMap)
	runtime.KeepAlive(cBuilderAllocMap)
	__v := *(**FfiBlockchainDataCtxT)(unsafe.Pointer(&__ret))
	return __v
}

// NewValueData function as declared in include/libmamoru_sniffer_go.h:262
func NewValueData(Value *FfiValueT) *FfiValueDataT {
	cValue, cValueAllocMap := (*C.FfiValue_t)(unsafe.Pointer(Value)), cgoAllocsUnknown
	__ret := C.new_value_data(cValue)
	runtime.KeepAlive(cValueAllocMap)
	__v := *(**FfiValueDataT)(unsafe.Pointer(&__ret))
	return __v
}

// NewValueBool function as declared in include/libmamoru_sniffer_go.h:265
func NewValueBool(Data bool) *FfiValueT {
	cData, cDataAllocMap := (C._Bool)(Data), cgoAllocsUnknown
	__ret := C.new_value_bool(cData)
	runtime.KeepAlive(cDataAllocMap)
	__v := *(**FfiValueT)(unsafe.Pointer(&__ret))
	return __v
}

// NewValueU64 function as declared in include/libmamoru_sniffer_go.h:268
func NewValueU64(Data uint64) *FfiValueT {
	cData, cDataAllocMap := (C.uint64_t)(Data), cgoAllocsUnknown
	__ret := C.new_value_u64(cData)
	runtime.KeepAlive(cDataAllocMap)
	__v := *(**FfiValueT)(unsafe.Pointer(&__ret))
	return __v
}

// NewValueList function as declared in include/libmamoru_sniffer_go.h:271
func NewValueList() *FfiValueT {
	__ret := C.new_value_list()
	__v := *(**FfiValueT)(unsafe.Pointer(&__ret))
	return __v
}

// ValueListAppend function as declared in include/libmamoru_sniffer_go.h:277
func ValueListAppend(ValueList *FfiValueT, Data *FfiValueT) bool {
	cValueList, cValueListAllocMap := (*C.FfiValue_t)(unsafe.Pointer(ValueList)), cgoAllocsUnknown
	cData, cDataAllocMap := (*C.FfiValue_t)(unsafe.Pointer(Data)), cgoAllocsUnknown
	__ret := C.value_list_append(cValueList, cData)
	runtime.KeepAlive(cDataAllocMap)
	runtime.KeepAlive(cValueListAllocMap)
	__v := (bool)(__ret)
	return __v
}

// NewValueStruct function as declared in include/libmamoru_sniffer_go.h:281
func NewValueStruct(Ty string) *FfiValueT {
	Ty = safeString(Ty)
	cTy, cTyAllocMap := unpackPCharString(Ty)
	__ret := C.new_value_struct(cTy)
	runtime.KeepAlive(Ty)
	runtime.KeepAlive(cTyAllocMap)
	__v := *(**FfiValueT)(unsafe.Pointer(&__ret))
	return __v
}

// ValueStructAddField function as declared in include/libmamoru_sniffer_go.h:288
func ValueStructAddField(ValueStruct *FfiValueT, Key string, Data *FfiValueT) bool {
	cValueStruct, cValueStructAllocMap := (*C.FfiValue_t)(unsafe.Pointer(ValueStruct)), cgoAllocsUnknown
	Key = safeString(Key)
	cKey, cKeyAllocMap := unpackPCharString(Key)
	cData, cDataAllocMap := (*C.FfiValue_t)(unsafe.Pointer(Data)), cgoAllocsUnknown
	__ret := C.value_struct_add_field(cValueStruct, cKey, cData)
	runtime.KeepAlive(cDataAllocMap)
	runtime.KeepAlive(Key)
	runtime.KeepAlive(cKeyAllocMap)
	runtime.KeepAlive(cValueStructAllocMap)
	__v := (bool)(__ret)
	return __v
}
